import * as React from 'react';
import { Component, Children } from 'react';
import { classNames, supports } from '@tolkam/lib-utils-ui';
import throttle from '@tolkam/lib-utils/throttle';
import debounce from '@tolkam/lib-utils/debounce';
import scrollTo, { TDirection, TEasing } from '@tolkam/lib-scroll-to';
import InView, { IVisibility, ISubject } from '@tolkam/react-in-view';

import * as Hammer from 'hammerjs';

import './defaults.scss';

const WIN = window;
const LOCAL_CLASS_NAME = 'rAgXf';
const SWIPE_PREV = 'swipeleft';
const SWIPE_NEXT = 'swiperight';
const PAN_PREV = 'panleft';
const PAN_NEXT = 'panright';
const PAN_START = 'panstart';
const PAN_END = 'panend';
const PAN_CANCEL = 'pancancel';

export default class Frames extends Component<IProps, any> {

    public static defaultProps = {
        startFrame: 0,
        scrollSpeed: 300,
        scrollEasing: 'easeOutQuad',
    };

    /**
     * Hammer instance
     * @type {HammerManager}
     */
    protected hammer: HammerManager;

    /**
     * Scrolling element
     * @type {HTMLDivElement}
     */
    protected parentRef: HTMLDivElement;

    /**
     * Frame elements
     * @type {NodeList}
     */
    protected childrenRefs: NodeListOf<HTMLDivElement>;

    /**
     * Whether client has scroll-snap support
     * @type {boolean}
     */
    protected isLegacy = true;

    /**
     * Scrolling state flag
     * @type {boolean}
     */
    protected isBusy = false;

    /**
     * Current active frame index
     * @type {number}
     */
    protected activeIndex = 0;

    /**
     * Current active frame index
     * @type {HTMLDivElement}
     */
    protected activeFrame: HTMLDivElement;

    /**
     * @param {IProps} props
     */
    public constructor(props: IProps) {
        super(props);

        // check new specs support
        this.isLegacy = !supports('scroll-snap-align: center');

        // throttled, so fires every N ms at most
        this.onResize = throttle(this.onResize, 200);

        // debounced, so fires at event end
        // this.onScroll = debounce(this.onScroll, 50);
    }

    /**
     * {@inheritDoc}
     */
    public componentDidMount() {
        const that = this;
        const direction = Hammer.DIRECTION_HORIZONTAL;

        that.hammer = new Hammer.Manager(that.parentRef, {
            recognizers: [
                [Hammer.Swipe, { direction }],
                [Hammer.Pan, { direction }, ['swipe']],
            ]
        });

        that.hammer.on([SWIPE_PREV, SWIPE_NEXT,
            PAN_START, PAN_PREV, PAN_NEXT,
            PAN_END, PAN_CANCEL].join(' '), that.onEvents);

        //
        WIN.addEventListener('resize', that.onResize);
        that.parentRef.addEventListener('scroll', that.onScroll);

        // get children refs
        that.childrenRefs = that.parentRef.childNodes as NodeListOf<HTMLDivElement>;

        // start from specific index
        // that.scrollTo(that.props.startFrame!, true);
    }

    /**
     * {@inheritDoc}
     */
    public componentWillUnmount() {
        const that = this;

        WIN.removeEventListener('resize', that.onResize);
        that.parentRef.removeEventListener('scroll', that.onScroll);
    }

    /**
     * {@inheritDoc}
     */
    public render() {
        const that = this;
        const { props, parentRef } = that;
        const { isVertical } = props;

        const className = classNames(props.className, LOCAL_CLASS_NAME, {
            [LOCAL_CLASS_NAME + '--h']: !isVertical,
            [LOCAL_CLASS_NAME + '--v']: isVertical,
            [LOCAL_CLASS_NAME + '--legacy']: that.isLegacy,
        });

        const parentProps = {
            ref: (r: HTMLDivElement) => that.parentRef = r,
            className: className,
        };

        // return <div {...parentProps}>
        //     <div className={LOCAL_CLASS_NAME + '__container'}>
        //         {Children.map(props.children, (child, i) =>
        //             <div className={LOCAL_CLASS_NAME + '__frame'}>{child}</div>
        //         )}
        //     </div>
        // </div>;

        return <div {...parentProps}>
            {Children.map(props.children, (child, i) =>
                <div className={LOCAL_CLASS_NAME + '__frame'}>{child}</div>
            )}
        </div>;
    }

    /**
     * Scrolls to next item
     *
     * @return void
     */
    public next() {
        this.scrollTo(this.getNextIndex(true));
    }

    /**
     * Scrolls to previous item
     *
     * @return void
     */
    public prev() {
        this.scrollTo(this.getNextIndex(false));
    }

    // protected onEvents = (e: HammerInput) => {
    //     const that = this;
    //     const hammer = that.hammer;
    //     console.log(e.type);
    //
    //     if(e.type === PAN_START) {
    //         console.log(e.type);
    //         that.lastScrollPos = that.parentRef.scrollLeft;
    //         return;
    //     }
    //
    //     if(e.type === SWIPE_PREV) {
    //         // that.next();
    //         that.lastScrollPos = that.parentRef.scrollLeft;
    //         hammer.stop(true);
    //     } else if(e.type === SWIPE_NEXT) {
    //         // that.prev();
    //         that.lastScrollPos = that.parentRef.scrollLeft;
    //         hammer.stop(true);
    //
    //
    //     } else if(e.type === PAN_PREV || e.type === PAN_NEXT) {
    //         that.parentRef.scrollLeft = that.lastScrollPos - e.deltaX;
    //
    //     } else if(e.type === PAN_END) {
    //         that.lastScrollPos = that.parentRef.scrollLeft;
    //     }
    //
    //     that.activeIndex = that.getActiveFrame();
    // };

    protected lastPosition = 0;

    protected onEvents = (e: HammerInput) => {
        const that = this;
        const hammer = that.hammer;
        const parent = that.parentRef;

        that.activeIndex = that.getActiveFrameIndex();

        switch(e.type) {
            case(PAN_PREV) :
            case(PAN_NEXT) :
                console.log('pan');
                parent.scrollLeft = that.lastPosition - e.deltaX;
                break;
            case(SWIPE_PREV) :
            case(SWIPE_NEXT) :
                console.log('swipe');
                e.type === SWIPE_PREV ? that.prev() : that.next();
                hammer.stop(true);

            // noinspection FallThroughInSwitchStatementJS
            case(PAN_END) :
            case(PAN_CANCEL) :

                // update last position on both swipe and end/cancel
                that.lastPosition = parent.scrollLeft;
                console.log('end');
                break;
        }

        if(e.isFinal && !that.isBusy) {
            that.scrollTo(that.activeIndex);
        }
    };



    protected onSwipe(e: HammerInput, hammer: HammerManager, parent: HTMLDivElement) {

    }

    protected onPan(e: HammerInput, hammer: HammerManager, parent: HTMLDivElement) {

    }

    /**
     * Scrolls to index
     *
     * @param {number} next
     * @param {boolean} instant
     */
    protected scrollTo = (next: number, instant: boolean = false) => {
        const that = this;
        const { parentRef, childrenRefs, props } = that;
        // const parentClassList = parentRef.classList;
        // const pauseSnapClass = LOCAL_CLASS_NAME + '--allow-scroll';

        // const speed = instant ? 0 : props.scrollSpeed;
        // const direction = props.isVertical ? 'Top' : 'Left';
        // const offsetProp = 'offset' + direction;

        const nextChild = childrenRefs[next];
        if (!nextChild) {
            console.warn('No child at index %s', next);
            return;
        }

        console.log('scrolling');

        that.isBusy = true;
        // // parentClassList.add(pauseSnapClass);
        //
        const pixels = nextChild['offsetLeft'] - parentRef['offsetLeft'];
        scrollTo('Left', parentRef, pixels, 300, 'easeInQuad', () => {
            // parentClassList.remove(pauseSnapClass);
            // that.activeIndex = next;
            // that.activeFrame = nextChild;
            that.isBusy = false;
            that.lastPosition = pixels;
        });
    };

    /**
     * Gets next item index depending on direction
     *
     * @param {boolean} fwd
     * @return {number}
     */
    protected getNextIndex(fwd: boolean) {
        const that = this;
        const total = React.Children.count(that.props.children);
        const current = that.activeIndex;

        return (fwd ? (current + 1) : (current + total - 1)) % total;
    }

    /**
     * Handles window resize
     *
     * @param {Event} e
     */
    protected onResize = (e: Event) => {
        const that = this;
        that.scrollTo(that.activeIndex, true);
    };

    /**
     * Handles parent scroll
     *
     * @param {MouseEvent} e
     */
    protected onScroll = (e: MouseEvent) => {
        // console.log(e);
        const that = this;

        // if (!that.isBusy) {
        //     // that.scrollTo(that.activeIndex);
        //     that.activeIndex = that.getActiveFrameIndex();
        // }
        that.activeIndex = that.getActiveFrameIndex();
    };

    protected getActiveFrameIndex() {
        const that = this;
        const { parentRef, childrenRefs } = that;

        const parentRect = parentRef.getBoundingClientRect();
        const parentStart = parentRect.left;
        const parentWidth = parentRect.width;
        const parentCenter = parentStart + parentWidth / 2;
        const parentEnd = parentStart + parentWidth;

        let active = 0;
        childrenRefs.forEach((child, i) => {

            const rect = child.getBoundingClientRect();
            const start = rect.left;
            const center = start + rect.width / 2;
            const end = start + rect.width;

            const startVisible = start >= parentStart && start < parentEnd;
            const centerVisible = center > parentStart && center < parentEnd;
            const endVisible = end < parentEnd && end >= parentStart;

            if(startVisible && centerVisible || centerVisible && endVisible) {
                active = i;
            }
        });

        return active;
    }
}

interface IProps extends React.HTMLAttributes<Frames> {

    // frame to start from, starting from 0
    startFrame?: number;

    // scroll direction
    isVertical?: boolean;
}
